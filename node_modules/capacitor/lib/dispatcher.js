(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  define(['invariant', 'signals'], function(invariant, _arg) {
    var Dispatcher, Signal;
    Signal = _arg.Signal;
    'use strict';
    Dispatcher = (function() {

      /*
       * @var {boolean} dispatching Wether or not the dispatcher is currently dispatching.
       * @private
       */
      var currentAction, currentPayload, dispatching, finalizeDispatching, isHandled, isPending, notifyStore, prepareForDispatching, storeID, stores;

      function Dispatcher() {
        this.dispatch = __bind(this.dispatch, this);
        this.waitFor = __bind(this.waitFor, this);
      }

      dispatching = false;


      /*
       * @var {integer} storeID ID to use for the next store that gets registered. 
       * @private
       */

      storeID = 0;


      /*
       * @var {object} stores Store registry.
       * @private
       */

      stores = {};


      /*
           * @var {object} isPending Object for tracking pending store callbacks.
       * @private
       */

      isPending = {};


      /*
           * @var {object} isPending Object for tracking handled store callbacks.
       * @private
       */

      isHandled = {};


      /*
           * @var {string} isPending The current action being dispatched, if any.
       * @private
       */

      currentAction = null;


      /*
           * @var {mixed} isPending The current payload being dispatched, if any.
       * @private
       */

      currentPayload = null;


      /*
           * @var {object} Signal triggered when the dispatcher is started.
       * @public
       */

      Dispatcher.prototype.started = new Signal();


      /*
           * @var {object} Signal triggered when the dispatcher is stopped.
       * @public
       */

      Dispatcher.prototype.stopped = new Signal();


      /*
           * Sets the dispatcher to a state where all stores are neither
           * pending nor handled.
           *
       * @private
       */

      prepareForDispatching = function() {
        var id;
        dispatching = true;
        for (id in stores) {
          isPending[id] = false;
          isHandled[id] = false;
        }
        return this.started.dispatch();
      };


      /*
           * Resets the dispatcher state after dispatching.
           *
       * @private
       */

      finalizeDispatching = function() {
        currentAction = null;
        currentPayload = null;
        dispatching = false;
        return this.stopped.dispatch();
      };


      /*
           * Calls the action handler on a store with the current action and payload.
           * This method is used when dispatching.
           *
           * @param {integer} id The ID of the store to notify
       * @private
       */

      notifyStore = function(id) {
        invariant((currentAction != null) && (currentPayload != null), "Cannot notify store without an action and a payload");
        isPending[id] = true;
        stores[id]._handleAction.call(stores[id], currentAction, currentPayload, this.waitFor);
        return isHandled[id] = true;
      };


      /*
           * Registers a store with the dispatcher so that it's notified when actions
           * are dispatched.
           *
           * @param {Object} store The store to register with the dispatcher
       */

      Dispatcher.prototype.register = function(store) {
        stores[storeID] = store;
        return store._id = storeID++;
      };


      /*
           * Unregisters a store from the dispatcher so that it's no longer 
           * notified when actions are dispatched.
           *
           * @param {Object} store The store to unregister from the dispatcher
       */

      Dispatcher.prototype.unregister = function(store) {
        invariant((store._id != null) && (stores[store._id] != null), "dispatcher.unregister(...): Store is not registered with the dispatcher.");
        return delete stores[store._id];
      };


      /*
           * Method for waiting for other stores to complete their handling
           * of actions. This method is passed along to the Stores when an action
           * is dispatched.
           *
           * @see notifyStore
       */

      Dispatcher.prototype.waitFor = function() {
        var dependency, id, storeDependencies, _i, _len, _results;
        storeDependencies = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        invariant(dispatching, "dispatcher.waitFor(): It's not possible to wait for dependencies when the dispatcher isn't dispatching.\nwaitFor() should be called in an action handler.");
        _results = [];
        for (_i = 0, _len = storeDependencies.length; _i < _len; _i++) {
          dependency = storeDependencies[_i];
          id = dependency._id;
          invariant((id != null) && (stores[id] != null), 'dispatcher.waitFor(...): dependency is not registered with the dispatcher.');
          if (isPending[id]) {
            invariant(isHandled[id], 'dispatcher.waitFor(...): Circular dependency detected.');
            continue;
          }
          _results.push(notifyStore.call(this, id));
        }
        return _results;
      };


      /*
           * Method for dispatching in action. This method is used by the Action class
           * when calling Action.dispatch().
           *
           * @param {string} actionName The name of the action to dispatch
           * @param {mixed} payload The payload for the event.
       */

      Dispatcher.prototype.dispatch = function(actionName, payload) {
        var id, _results;
        invariant(!dispatching, 'dispatcher.dispatch(...): Cannot dispatch in the middle of a dispatch.');
        currentAction = actionName;
        currentPayload = payload;
        prepareForDispatching.call(this);
        try {
          _results = [];
          for (id in stores) {
            if (isPending[id]) {
              continue;
            }
            _results.push(notifyStore.call(this, id));
          }
          return _results;
        } finally {
          finalizeDispatching.call(this);
        }
      };

      return Dispatcher;

    })();
    return new Dispatcher();
  });

}).call(this);
